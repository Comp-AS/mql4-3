//+------------------------------------------------------------------+
//| Strategy 1.602 EA
//|
//|    Generated by StrategyQuant version 3.1.1
//|    Generated at Sun Jan 26 02:50:00 GMT 2014
//|                                                          
//|    Tested on EURUSD_Tick, H1, 30.03.2007 - 24.01.2014
//|    Spread: 3.0, Slippage: 0.0, Min distance of stop from price: 5
//+------------------------------------------------------------------+

#property copyright "StrategyQuant.com"
#property link      "http://www.StrategyQuant.com"
#include <stdlib.mqh>

//+------------------------------------------------------------------+
// -- SL/PT Parameters
//+------------------------------------------------------------------+
extern string __s2 = "-----  SL/PT Parameters  ----------------------";

// this is the minimum and maximum value for PT & SL used,
// any bigger or smaller value will be capped to this range
extern double MinimumSLPT = 10;
extern double MaximumSLPT = 100;

//+------------------------------------------------------------------+
// -- Money Management Parameters
//+------------------------------------------------------------------+
extern string __s6 = "-----  Money Management Parameters  -----------";
extern bool UseMoneyManagement = false;
extern double Lots = 0.1;
extern int LotsDecimals = 2;
extern double RiskInPercent = 2.0;
extern double MaximumLots = 0.5;
extern bool UseFixedMoney = false;
extern double RiskInMoney = 100.0;

//+------------------------------------------------------------------+
// -- Trading Logic Settings
//+------------------------------------------------------------------+
extern string __s7 = "-----  Trading Logic Settings  ----------------";
extern int MaxTradesPerDay = 0; // 0 means unlimited
extern bool ReplacePendingOrders = true;
extern bool LimitSignalsToRange = false;
extern string TimeRangeFrom = "08:00";
extern string TimeRangeTo = "16:00";
extern bool ExitAtEndOfRange = false;
extern bool ExitAtEndOfDay = false;
extern string ExitTimeEOD = "00:00";
extern bool ExitOnFriday = false;
extern string ExitTimeOnFriday = "00:00";

extern bool TradeLong = true;
extern bool TradeShort = true;

//+------------------------------------------------------------------+
// -- Trading Date Parameters
//+------------------------------------------------------------------+
extern string __s8 = "-----  Trading Date Parameters  ---------------";
extern bool TradeSunday = false;
extern bool TradeMonday = true;
extern bool TradeTuesday = true;
extern bool TradeWednesday = true;
extern bool TradeThursday = true;
extern bool TradeFriday = true;
extern bool TradeSaturday = false;


//+------------------------------------------------------------------+
// -- Other Parameters
//+------------------------------------------------------------------+
extern string __s9 = "-----  Other Parameters  ----------------------";
extern int MaxSlippage = 3;
extern string CustomComment = "Strategy 1.602";
extern int MagicNumber = 12345;
extern bool EmailNotificationOnTrade = false;

//+------------------------------------------------------------------+
// -- Other Hidden Parameters
//+------------------------------------------------------------------+
int MinDistanceOfStopFromPrice = 5;
double gPointPow = 0;
double gPointCoef = 0;
double gbSpread = 3.0;
double brokerStopDifference = 0;
string eaStopDifference = "";
double eaStopDifferenceNumber = 0;
int lastHistoryPosChecked = 0;
int lastHistoryPosCheckedNT = 0;
string currentTime = "";
string lastTime = "";
bool tradingRangeReverted = false;
string sqLastPeriod;
bool sqIsBarOpen;

/**
 * add your own parameters that will be included in every EA
 * into file /code/CustomParametersMT4.mq4
 */
//extern bool TradeOnHour1 = true;


//+------------------------------------------------------------------+
// -- Functions
//+------------------------------------------------------------------+

int start() {

   if(!customStart()) return(0);

   if(!manageTrades()) return(0);

   //-------------------------------------------
   // ENTRY RULES

   // LONG: Short Term CCI(20) < 0
   if(TradeLong) {
      bool LongEntryCondition = ruleShortTermCCI_Below();
      if(LongEntryCondition == true) {
         openPosition(1);
      }
   }
   
   // SHORT: Short Term CCI(20) > 0
   if(TradeShort) {
      bool ShortEntryCondition = ruleShortTermCCI_Above();
      if(ShortEntryCondition == true) {
         openPosition(-1);
      }
   }

   if(getMarketPosition() != 0) {
      //-------------------------------------------
      // EXIT RULES
      if(isMarketLongPosition()) {
         // we are in LONG position
         if (getOpenBarsForOrder(53) >= 53) {
             closePositionAtMarket();
          }

      }
   
      if(isMarketShortPosition()) {
         // we are in SHORT position
         if (getOpenBarsForOrder(53) >= 53) {
             closePositionAtMarket();
          }

      }

      manageStop();
   }

   return(0);
}

//+------------------------------------------------------------------+

int init() {
   Log("--------------------------------------------------------");
   Log("Starting the EA");

   double realDigits;
   if(Digits < 2) {
      realDigits = 0;
   } else if (Digits < 4) {
      realDigits = 2;
   } else {
      realDigits = 4;
   }

   gPointPow = MathPow(10, realDigits);
   gPointCoef = 1/gPointPow;

   brokerStopDifference = gPointPow*MarketInfo(Symbol(),MODE_STOPLEVEL)/MathPow(10, Digits);

   eaStopDifferenceNumber = MinDistanceOfStopFromPrice/gPointPow;

   eaStopDifference = DoubleToStr(MinDistanceOfStopFromPrice, 2);
   Log("Broker Stop Difference: ",DoubleToStr(brokerStopDifference, 2),", EA Stop Difference: ",eaStopDifference);

   if(DoubleToStr(brokerStopDifference, 2) != eaStopDifference) {
      Log("WARNING! EA Stop Difference is different from real Broker Stop Difference, the backtest results in MT4 could be different from results of Genetic Builder!");
   }

   string brokerSpread = DoubleToStr((Ask - Bid)*gPointPow, 2);
   string strGbSpread = DoubleToStr(gbSpread, 2);
   Log("Broker spread: ",brokerSpread,", Genetic Builder test spread: ",strGbSpread);

   if(strGbSpread != brokerSpread) {
      Log("WARNING! Real Broker spread is different from spread used in Genetic Builder, the backtest results in MT4 could be different from results of Genetic Builder!");
   }

   if(StrToTime(TimeRangeTo) < StrToTime(TimeRangeFrom)) {
      tradingRangeReverted = true;
      Log("Trading range s reverted, from: ", TimeRangeFrom," to ", TimeRangeTo);
   } else {
      tradingRangeReverted = false;
   }

   Log("--------------------------------------------------------");

   customInit();

   return(0);
}

//+------------------------------------------------------------------+

double getSpecialSL(double value) {
   return(value);
}

double getSpecialPT(double value) {
   return(value);
}

double getNormalSL(double value) {
   return(value);
}

double getNormalPT(double value) {
   return(value);
}

double getBid() {
   return(Bid);
}

double getAsk() {
   return(Ask);
}

//+------------------------------------------------------------------+

void manageTradeSLPT() {
}

//+------------------------------------------------------------------+

double getTradeOpenPrice(int tradeDirection) {
   double rangeValue;

   RefreshRates();

   if(tradeDirection == 1) {
      // long
         return(HeikenAshiOpen(7) + (-0.1) * (gbBarRange(2, 1)));
   } else {
      // short
      return(HeikenAshiOpen(7) + (0.1) * (gbBarRange(2, 1)));
   }
}

//+------------------------------------------------------------------+

double getStopLoss(int tradeDirection) {
   if(tradeDirection == 1) {
      // long
      return(checkCorrectMinMaxSLPT(10 * gPointCoef));
   } else {
      // short
      return(checkCorrectMinMaxSLPT(10 * gPointCoef));
   }
}

//+------------------------------------------------------------------+

double getProfitTarget(int tradeDirection) {
   if(tradeDirection == 1) {
      // long
   } else {
      // short
   }
}
//+------------------------------------------------------------------+

double getProfitTrailingByTick() {
   if (OrderType() == OP_BUY) {
      // long
   } else if (OrderType() == OP_SELL) {
      // short
   }

   return(0);
}

//+------------------------------------------------------------------+

double getStopTrailingByClose() {
   double value = 0;
   if (OrderType() == OP_BUY) {
      value = HeikenAshiHigh(7) + (0.6) * (MathAbs(HeikenAshiHigh(12) - iCustom(NULL,0, "KeltnerChannel", 46, 2.1, 2, 1)));

   } else if (OrderType() == OP_SELL) {
      value = HeikenAshiLow(7) + (-0.6) * (MathAbs(HeikenAshiLow(12) - iCustom(NULL,0, "KeltnerChannel", 46, 2.1, 0, 1)));
   }

   return(value);
}

//+------------------------------------------------------------------+

double getMoveSLValueByTick() {
   if (OrderType() == OP_BUY) {
      // long
   } else if (OrderType() == OP_SELL) {
      // short
   }

   return(0);
}

//+------------------------------------------------------------------+

bool manageTrades() {
   if(Bars<30) {
      Print("NOT ENOUGH DATA: Less Bars than 30");
      return(0);
   }

   string currentPeriod = sqGetTimeAsStr();
   if(currentPeriod == sqLastPeriod) {
      sqIsBarOpen = false;
   } else {
      sqLastPeriod = currentPeriod;
      sqIsBarOpen = true;
   }

   if(!sqIsBarOpen) return(false);

   closeTradesAtEndOfRange();

   if(getMarketPosition() != 0) {
      manageTradeSLPT();
   }

   manageOrdersExpiration();

   if(LimitSignalsToRange && checkInsideTradingRange() == false) {
      return(false);
   }

   if(!isCorrectDayOfWeek(Time[0])) {
      return(false);
   }

   if(MaxTradesPerDay > 0) {
     if(getNumberOfTradesToday() >= MaxTradesPerDay) {
        return(false);
     }
   }

   return(true);
}

//+------------------------------------------------------------------+

void closeTradesAtEndOfRange() {
   if(isSomeOrderActive() != 0) {
      if(ExitAtEndOfDay) {
         if(ExitTimeEOD == "00:00" || ExitTimeEOD == "0:00") {
            closeTradeFromPreviousDay();
         } else if(TimeCurrent() >= StrToTime(ExitTimeEOD)) {
            closeActiveOrders();
            closePendingOrders();
         }
      }

      if(ExitOnFriday) {
         int dow = TimeDayOfWeek(Time[0]);

         if(ExitTimeOnFriday == "00:00" || ExitTimeOnFriday == "0:00") {
            if(dow == 6 || dow == 0 || dow == 1) {
               closeTradeFromPreviousDay();
            }
         } else if(TimeCurrent() >= StrToTime(ExitTimeOnFriday)) {
            closeActiveOrders();
            closePendingOrders();
         }
      }
   }

   if(LimitSignalsToRange) {
      if(checkInsideTradingRange() == false) {
         // we are out of allowed trading hours
         if(ExitAtEndOfRange) {
            if(tradingRangeReverted == false && TimeCurrent() > StrToTime(TimeRangeTo)) {
               closeActiveOrders();
               closePendingOrders();
            } else if(tradingRangeReverted == true && TimeCurrent() > StrToTime(TimeRangeTo) && TimeCurrent() < StrToTime(TimeRangeFrom)) {
               closeActiveOrders();
               closePendingOrders();
            }
         }
      }
   }
}

//+------------------------------------------------------------------+

double gbTrueRange(int period, int index) {
   int period1 = period + index-1;
   int period2 = period + index;
   return (MathMax(High[period1], Close[period2]) - MathMin(Low[period1], Close[period2]));
}

//+------------------------------------------------------------------+

double gbBarRange(int period, int index) {
   int period2 = period + index-1;
   return (MathAbs(High[period2] - Low[period2]));
}

//+------------------------------------------------------------------+

void openPosition(int tradeDirection) {
   if(tradeDirection == 0) return(0);


   if(checkTradeClosedThisBar()) {
      return(0);
   }

//   if(checkTradeClosedThisMinute()) {
//      return(0);
//   }

   //---------------------------------------
   // get order price
   double openPrice = NormalizeDouble(getTradeOpenPrice(tradeDirection), Digits);

   //---------------------------------------
   // get order type
   int orderType;
   if(tradeDirection == 1) {
      if(getMarketPosition() != 0) return;

      orderType = OP_BUYLIMIT;
   } else {
      if(getMarketPosition() != 0) return;

      orderType = OP_SELLLIMIT;
   }

   if(orderType != OP_BUY && orderType != OP_SELL) {
      // it is stop or limit order
      double AskOrBid;
      if(tradeDirection == 1) { AskOrBid = Ask; } else { AskOrBid = Bid; }

      // check if stop/limit price isn't too close
      if(NormalizeDouble(MathAbs(openPrice - AskOrBid), Digits) <= NormalizeDouble(eaStopDifferenceNumber, Digits)) {
         //Log("stop/limit order is too close to actual price");
         return(0);
      }

      // check price according to order type
      if(orderType == OP_BUYSTOP) {
         if(AskOrBid >= openPrice) return(0);
      } else if(orderType == OP_SELLSTOP) {
         if(AskOrBid <= openPrice) return(0);

      } else if(orderType == OP_BUYLIMIT) {
         if(AskOrBid <= openPrice) return(0);
      } else if(orderType == OP_SELLLIMIT) {
         if(AskOrBid >= openPrice) return(0);
      }

      // there can be only one active order of the same type
      if(checkPendingOrderAlreadyExists(orderType)) {
         if(!ReplacePendingOrders) {
            return(0);
         } else {
            closePendingOrder();
         }
      }
   }

   //---------------------------------------
   // add SL/PT
   double stopLoss = 0;
   double profitTarget = 0;

   double SL = NormalizeDouble(getStopLoss(tradeDirection), Digits);
   double PT = NormalizeDouble(getProfitTarget(tradeDirection), Digits);

   if(SL != 0) {
      stopLoss = openPrice - tradeDirection * SL;
   }
   if(PT != 0) {
      profitTarget = openPrice + tradeDirection * PT;
   }

   string comment = CustomComment;

   double orderLots = getLots(SL*gPointPow);
   if(orderLots > MaximumLots) {
      orderLots = MaximumLots;
   }

   // open order with error handling and retries
   int ticket = 0;
   int retries = 3;
   while(true) {
      retries--;
      if(retries < 0) return(0);
      if(getMarketPosition() != 0) return(0);

      if(sqIsTradeAllowed() == 1) {
         ticket = openOrderWithErrorHandling(orderType, orderLots, openPrice, stopLoss, profitTarget, comment, MagicNumber);
         if(ticket > 0) {
            return(true);
         }
      }

      if(ticket == -130 || ticket == -131) {
         // invalid stops or volume, we cannot open the trade
         return(false);
      }

      Sleep(1000);
   }
}

//+------------------------------------------------------------------+

int openOrderWithErrorHandling(int orderType, double orderLots, double openPrice, double stopLoss, double profitTarget, string comment, int MagicNumber) {

   //---------------------------------------
   // send order
   int error, ticket;
   Log("Opening order, direction: ", orderType,", price: ", openPrice, ", Ask: ", Ask, ", Bid: ", Bid);
   ticket = OrderSend(Symbol(), orderType, orderLots, openPrice, MaxSlippage, 0, 0, comment, MagicNumber, 0, Green);
   if(ticket < 0) {
      // order failed, write error to log
      error = GetLastError();
      Log("Error opening order: ",error, " : ", ErrorDescription(error));
      return(error);
   }

   OrderSelect(ticket, SELECT_BY_TICKET, MODE_TRADES);
   Log("Order opened: ", OrderTicket(), " at price:", OrderOpenPrice());

   stopLoss = getSpecialSL(stopLoss);
   profitTarget = getSpecialPT(profitTarget);

   if(EmailNotificationOnTrade) {
      SendMail("GB Strategy - Order opened", getNotificationText());
   }

   // set up stop loss and profit target");
   // It has to be done separately to support ECN brokers
   if(stopLoss != 0 || profitTarget != 0) {
      Log("Setting SL/PT, SL: ", stopLoss, ", PT: ", profitTarget);
      if(OrderModify(ticket, OrderOpenPrice(), stopLoss, profitTarget, 0, 0)) {
         Log("Order modified, StopLoss: ", OrderStopLoss(),", Profit Target: ", OrderTakeProfit());
      } else {
         Log("Error modifying order: ",error, " : ", ErrorDescription(error));
      }
   }

   return(ticket);
}

//+------------------------------------------------------------------+
/**
 * manage trade - move SL to break even or trailing stop
 */
void manageStop() {

   double trailingStopValue, moveSLValue;
   double orderSL, normalOrderSL, orderOpen;
   double close = Close[1];
   double tsLevel, newSL;

   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {

         if(OrderType() != OP_BUY && OrderType() != OP_SELL) continue;
         if(OrderOpenTime() >= Time[0]) continue; // exit if the order was just opened

         //------------------------------
         // profit trailing on close
         trailingStopValue = getProfitTrailingByTick();
         if(trailingStopValue > 0) {
            if(OrderType() == OP_BUY) {
               tsLevel = close - trailingStopValue;
            } else {
  	            tsLevel = close + trailingStopValue;
            }
            orderSL = OrderStopLoss();
            normalOrderSL = getNormalSL(orderSL);
            newSL = getSpecialSL(tsLevel);

            if(OrderType() == OP_BUY) {
               if(isSLCorrect(tsLevel) && (orderSL == 0 || normalOrderSL < tsLevel) && !doublesAreEqual(orderSL, newSL)) {
     	            OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0);
     	         }
            } else {
     	         if (isSLCorrect(tsLevel) && (orderSL == 0 || normalOrderSL > tsLevel)  && !doublesAreEqual(orderSL, newSL)) {
     	            OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0);
     	         }
            }
         }

			//--------------------------------------------------------
   		// manage stop trailing on close
         trailingStopValue = getStopTrailingByClose();
         if(trailingStopValue > 0) {
            orderOpen = OrderOpenPrice();
            orderSL = OrderStopLoss();
            normalOrderSL = getNormalSL(orderSL);
            newSL = getSpecialSL(trailingStopValue);

            if(OrderType() == OP_BUY) {
              	if(isSLCorrect(trailingStopValue) && (orderSL == 0 || normalOrderSL < trailingStopValue) && !doublesAreEqual(orderSL, newSL)) {
	           		OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0);
	           	}
	         } else {
	          	if (isSLCorrect(trailingStopValue) && (orderSL == 0 || normalOrderSL > trailingStopValue) && !doublesAreEqual(orderSL, newSL)) {
	           		OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0);
	           	}
	         }
         }

         //--------------------------------------------------------
         // manage SL 2 BE (by tick)
         moveSLValue = getMoveSLValueByTick();
         if(moveSLValue > 0) {
            orderSL = OrderStopLoss();
            normalOrderSL = getNormalSL(orderSL);
            orderOpen = OrderOpenPrice();
            newSL = getSpecialSL(orderOpen);

            if(OrderType() == OP_BUY) {
               if(isSLCorrect(orderOpen) && (getBid() - orderOpen >= moveSLValue) && (orderSL == 0 || normalOrderSL < orderOpen) && !doublesAreEqual(orderSL, newSL)) {
                  OrderModify(OrderTicket(), orderOpen, newSL, OrderTakeProfit(), 0);
               }
            } else {
               if (isSLCorrect(orderOpen) && (orderOpen - getAsk() >= moveSLValue) && (orderSL == 0 || normalOrderSL > orderOpen) && !doublesAreEqual(orderSL, newSL)) {
                  OrderModify(OrderTicket(), orderOpen, newSL, OrderTakeProfit(), 0);
               }
            }
         }
      }
   }
}
//+------------------------------------------------------------------+

bool isSLCorrect(double slPrice) {
   double slDistance = MarketInfo(Symbol(),MODE_STOPLEVEL)/MathPow(10, Digits);

   eaStopDifferenceNumber = MinDistanceOfStopFromPrice/gPointPow;
   if(OrderType() == OP_BUY) {
      if(slPrice < (Bid-slDistance)) {
         return(true);
      }
   } else {
      if(slPrice > (Ask+slDistance)) {
         return(true);
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool checkPendingOrderAlreadyExists(int orderType) {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol() && OrderType() == orderType) {
         return(true);
      }
   }
}

//+------------------------------------------------------------------+

void closePendingOrder() {
   OrderDelete(OrderTicket());
}

//+------------------------------------------------------------------+

int getMarketPosition() {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         if(OrderType() == OP_BUY) {
            return(1);
         }
         if(OrderType() == OP_SELL) {
            return(-1);
       }
     }
   }

   return(0);
}

//+------------------------------------------------------------------+

int isMarketLongPosition() {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         if(OrderType() == OP_BUY) {
            return(true);
         }
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

int isMarketShortPosition() {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         if(OrderType() == OP_SELL) {
            return(true);
         }
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool isSomeOrderActive() {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         return(true);
     }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool checkItIsPendingOrder() {
   if(OrderType() != OP_BUY && OrderType() != OP_SELL) {
     return(true);
   }
}

//+------------------------------------------------------------------+

bool selectOrderByMagicNumber() {
   for(int i=0; i<OrdersTotal(); i++) {
     if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {

       return(true);
     }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool selectOpenOrderByMagicNumber() {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {

         if(checkItIsPendingOrder()) {
            continue;
         }

         return(true);
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

void closePositionAtMarket() {
   RefreshRates();
   double priceCP;

   if(OrderType() == OP_BUY) {
      priceCP = Bid;
   } else {
      priceCP = Ask;
   }

   OrderClose(OrderTicket(), OrderLots(), priceCP, MaxSlippage);
}

//+------------------------------------------------------------------+

void Log(string s1, string s2="", string s3="", string s4="", string s5="", string s6="", string s7="", string s8="", string s9="", string s10="", string s11="", string s12="" ) {
   Print(TimeToStr(TimeCurrent()), " ", s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);
}

//+------------------------------------------------------------------+

void closeTradeFromPreviousDay() {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         int orderType = OrderType();

         if(TimeToStr(Time[0], TIME_DATE) != TimeToStr(OrderOpenTime(), TIME_DATE)) {
            if (orderType == OP_BUY || orderType == OP_SELL) {
               closePositionAtMarket();
            } else {
               OrderDelete(OrderTicket());
            }
         }
      }
   }
}

//+------------------------------------------------------------------+

double getHighest(int period, int shift) {
   double maxnum = -1000;

   for(int i=shift; i<shift+period; i++) {
      if(High[i] > maxnum) {
         maxnum = High[i];
      }
   }

   return(maxnum);
}

//+------------------------------------------------------------------+

double getLowest(int period, int shift) {
   double minnum = 1000;

   for(int i=shift; i<shift+period; i++) {
      if(Low[i] < minnum) {
         minnum = Low[i];
      }
   }

   return(minnum);
}

//+------------------------------------------------------------------+

bool timeIsLower(datetime dt, int toHour, int toMinute) {
	if(toHour == 0 && TimeHour(dt) == 23) return (true);
	if(TimeHour(dt) < toHour) return(true);
	if(TimeHour(dt) > toHour) return (false);

	if(TimeMinute(dt) < toMinute) return (true);
	if(TimeMinute(dt) >  toMinute) return (false);

	return (false);
}

bool timeIsBiggerOrEqual(datetime dt, int toHour, int toMinute) {
		if(TimeHour(dt) < toHour) return (false);
		if(TimeHour(dt) > toHour) return (true);

		if(TimeMinute(dt) < toMinute) return (false);
		if(TimeMinute(dt) >=  toMinute) return (true);

		return (false);
}

//+------------------------------------------------------------------+

double getHighestInRange(int fromHour, int fromMinute, int toHour, int toMinute) {
   int indexTo = -1;
   int indexFrom = -1;

   // find index of bar for timeTo
   for(int i=1; i<=3000; i++) {
      if(timeIsBiggerOrEqual(Time[i], toHour, toMinute) && timeIsLower(Time[i+1], toHour, toMinute)) {
         indexTo = i;
         break;
      }
   }

   if(indexTo == -1) {
      Log("Not found indexTo");
      return(-1);
   }

   // find index of bar for timeFrom
   for(i=1; i<=3000; i++) {
      if(i <= indexTo) continue;

      if(timeIsBiggerOrEqual(Time[i], fromHour, fromMinute) && timeIsLower(Time[i+1], fromHour, fromMinute)) {
         indexFrom = i;
         break;
      }
   }

   if(indexFrom == -1) {
      Log("Not found indexFrom");
      return(0);
   }

   double value = -10000.0;

   for(i=indexTo; i<=indexFrom; i++) {
      value = MathMax(value, iHigh(NULL, 0, i));
   }

   return(value);
}

//+------------------------------------------------------------------+

double getLowestInRange(int fromHour, int fromMinute, int toHour, int toMinute) {
   int indexTo = -1;
   int indexFrom = -1;

   // find index of bar for timeTo
   for(int i=1; i<=3000; i++) {
      if(timeIsBiggerOrEqual(Time[i], toHour, toMinute) && timeIsLower(Time[i+1], toHour, toMinute)) {
         indexTo = i;
         break;
      }
   }

   if(indexTo == -1) {
      Log("Not found indexTo");
      return(-1);
   }

   // find index of bar for timeFrom
   for(i=1; i<=3000; i++) {
      if(i <= indexTo) continue;

      if(timeIsBiggerOrEqual(Time[i], fromHour, fromMinute) && timeIsLower(Time[i+1], fromHour, fromMinute)) {
         indexFrom = i;
         break;
      }
   }

   if(indexFrom == -1) {
      Log("Not found indexFrom");
      return(0);
   }

   double value = 100000.0;

   for(i=indexTo; i<=indexFrom; i++) {
      value = MathMin(value, iLow(NULL, 0, i));
   }

   return(value);
}

//+------------------------------------------------------------------+

double getTimeRange(int fromHour, int fromMinute, int toHour, int toMinute) {
   return(getHighestInRange(fromHour, fromMinute, toHour, toMinute) - getLowestInRange(fromHour, fromMinute, toHour, toMinute));
}

//+------------------------------------------------------------------+

void manageOrdersExpiration() {

   currentTime = getPeriodAsStr();
   if(currentTime == lastTime) {
      return;
   }

   int barsOpen = 0;
   int orderType;
   int exitBars = 0;
   int expiration = 0;

   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         orderType = OrderType();

         if (orderType == OP_BUY || orderType == OP_SELL) {
            // it is active order
            // do nothing
         } else {
            // it is stop/limit pending order
            if(orderType == OP_BUYLIMIT || orderType == OP_BUYSTOP) {
               expiration = 17;
               if(expiration > 0) {
                  barsOpen = getOpenBarsForOrder(expiration);
                  if(barsOpen >= expiration) {
                     OrderDelete(OrderTicket());
                  }
               }
            } else if (orderType == OP_SELLLIMIT || orderType == OP_SELLSTOP) {
               expiration = 17;
               if(expiration > 0) {
                  barsOpen = getOpenBarsForOrder(expiration);
                  if(barsOpen >= expiration) {
                     OrderDelete(OrderTicket());
                  }
               }
            }
         }
      }
   }

   lastTime = currentTime;
}

//+------------------------------------------------------------------+

void closePendingOrders() {
   int orderType;

   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         orderType = OrderType();

         if (orderType == OP_BUY || orderType == OP_SELL) {
            continue;
         }

         OrderDelete(OrderTicket());
      }
   }
}

//+------------------------------------------------------------------+

void closeActiveOrders() {
   int orderType;

   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         orderType = OrderType();

         if (orderType == OP_BUY || orderType == OP_SELL) {
            closePositionAtMarket();
         }
      }
   }
}

//+------------------------------------------------------------------+

int getOpenBarsForOrder(int expBarsPeriod) {
   datetime opTime = OrderOpenTime();
   datetime currentTime = TimeCurrent();

   int numberOfBars = 0;
   for(int i=0; i<expBarsPeriod+10; i++) {
      if(opTime < Time[i]) {
         numberOfBars++;
      }
   }

   return(numberOfBars);
}

//+------------------------------------------------------------------+

string getPeriodAsStr() {
   string str = TimeToStr(TimeCurrent(), TIME_DATE);
   int period = Period();

   if(period == PERIOD_H4 || period == PERIOD_H1) {
      str = str + TimeHour(TimeCurrent());
   }
   if(period == PERIOD_M30 || period == PERIOD_M15 || period == PERIOD_M5 || period == PERIOD_M1) {
      str = str + " " + TimeToStr(TimeCurrent(), TIME_MINUTES);
   }

   return(str);
}

//+------------------------------------------------------------------+

bool checkTradeClosedThisMinute() {
   string currentTime = TimeToStr( TimeCurrent(), TIME_DATE|TIME_MINUTES);

   int startAt = lastHistoryPosChecked-10;
   if(startAt < 0) {
      startAt = 0;
   }

   for(int i=startAt;i<OrdersHistoryTotal();i++) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         string orderTime = TimeToStr( OrderCloseTime(), TIME_DATE|TIME_MINUTES);

         lastHistoryPosChecked = i;

         if(orderTime == currentTime) {
            return(true);
         }
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool checkTradeClosedThisBar() {
   int startAt = lastHistoryPosChecked-10;
   if(startAt < 0) {
      startAt = 0;
   }

   for(int i=startAt;i<OrdersHistoryTotal();i++) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         if((OrderType() == OP_BUY || OrderType() == OP_SELL) && OrderCloseTime() >= Time[0]) {
            return(true);
         }
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

int getNumberOfTradesToday() {
   int startAt = lastHistoryPosCheckedNT-10;
   if(startAt < 0) {
      startAt = 0;
   }

   string currentTime = TimeToStr( TimeCurrent(), TIME_DATE);
   int count = 0;

   for(int i=startAt;i<OrdersHistoryTotal();i++) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         string orderTime = TimeToStr( OrderOpenTime(), TIME_DATE);

         lastHistoryPosCheckedNT = i;

         if(orderTime == currentTime) {
            count++;
         }
      }
   }

   for(i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         orderTime = TimeToStr( OrderOpenTime(), TIME_DATE);

         if(orderTime == currentTime) {
            count++;
         }
      }
   }

   return(count);
}

//+------------------------------------------------------------------+

//+------------------------------------------------------------------+

double getLots(double slSize) {
   if(slSize <= 0) {
      return(Lots);
   }

   if(UseMoneyManagement == false) {
      if(Lots > MaximumLots) {
         return(MaximumLots);
      }

      return(Lots);
   }

   if(UseFixedMoney) {
      return(getLotsFixedMoney(slSize));
   } else {
      return(getLotsRiskPercentage(slSize));
   }
}

//+------------------------------------------------------------------+

double getLotsFixedMoney(double slSize) {
   if(RiskInMoney <0 ) {
      Log("Incorrect RiskInPercent size, it must be above 0");
      return(0);
   }

   double riskPerTrade = RiskInMoney;
   return(computeMMFromRiskPerTrade(riskPerTrade, slSize));
}

//+------------------------------------------------------------------+

double getLotsRiskPercentage(double slSize) {
   if(RiskInPercent <0 ) {
      Log("Incorrect RiskInPercent size, it must be above 0");
      return(0);
   }

   double riskPerTrade = (AccountBalance() *  (RiskInPercent / 100.0));
   return(computeMMFromRiskPerTrade(riskPerTrade, slSize));
}

//+------------------------------------------------------------------+

double computeMMFromRiskPerTrade(double riskPerTrade, double slSize) {
   if(slSize <= 0) {
      Log("Incorrect StopLossPips size, it must be above 0");
      return(0);
   }

   // adjust money management for non-US currencies
   double CurrencyAdjuster=1;
   if (MarketInfo(Symbol(),MODE_TICKSIZE)!=0) CurrencyAdjuster=MarketInfo(Symbol(),MODE_TICKVALUE) * (MarketInfo(Symbol(),MODE_POINT) / MarketInfo(Symbol(),MODE_TICKSIZE));

   double lotMM1 = NormalizeDouble(riskPerTrade / CurrencyAdjuster / (slSize * 10.0), LotsDecimals);
   double lotMM;
   double lotStep = MarketInfo(Symbol(), MODE_LOTSTEP);
   if(MathMod(lotMM*100, lotStep*100) > 0) {
      lotMM = lotMM1 - MathMod(lotMM1, lotStep);
   } else {
      lotMM = lotMM1;
   }

   lotMM = NormalizeDouble( lotMM, LotsDecimals);

   if(MarketInfo(Symbol(), MODE_LOTSIZE)==10000.0) lotMM=lotMM*10.0 ;
   lotMM=NormalizeDouble(lotMM,LotsDecimals);

   //Log("Computing lots, risk: ", riskPerTrade, ", lotMM1: ", lotMM1, ", lotStep: ", lotStep, ", lots: ", lotMM);
   double Smallest_Lot = MarketInfo(Symbol(), MODE_MINLOT);
   double Largest_Lot = MarketInfo(Symbol(), MODE_MAXLOT);

   if (lotMM < Smallest_Lot) lotMM = Smallest_Lot;
   if (lotMM > Largest_Lot) lotMM = Largest_Lot;

   if(lotMM > MaximumLots) {
      lotMM = MaximumLots;
   }

   //Log("SL size: ", slSize, ", LotMM: ", lotMM);

   return (lotMM);
}

//+------------------------------------------------------------------+
//+ Heiken Ashi functions
//+------------------------------------------------------------------+

double HeikenAshiOpen(int shift) {
   return(iCustom( NULL, 0, "Heiken Ashi", 0,0,0,0, 2, shift));
}

double HeikenAshiClose(int shift) {
   return(iCustom( NULL, 0, "Heiken Ashi", 0,0,0,0, 3, shift));
}

double HeikenAshiHigh(int shift) {
   return(MathMax(iCustom( NULL, 0, "Heiken Ashi", 0,0,0,0, 0, shift), iCustom( NULL, 0, "Heiken Ashi", 0,0,0,0, 1, shift)));
}

double HeikenAshiLow(int shift) {
   return(MathMin(iCustom( NULL, 0, "Heiken Ashi", 0,0,0,0, 0, shift), iCustom( NULL, 0, "Heiken Ashi", 0,0,0,0, 1, shift)));
}

//+------------------------------------------------------------------+
//+ Simple rules functions
//+------------------------------------------------------------------+

bool ruleCloseAboveBB() {
   return (Close[1] > iBands(NULL,0, 20, 2, 0, PRICE_CLOSE, MODE_UPPER, 1)) ;
}

bool ruleCloseBelowBB() {
   return (Close[1] < iBands(NULL,0, 20, 2, 0, PRICE_CLOSE, MODE_LOWER, 1)) ;
}

bool ruleCloseAbovePSAR() {
   return (Close[1] > iSAR(NULL,0, 0.02, 0.2, 1)) ;
}

bool ruleCloseBelowPSAR() {
   return (Close[1] < iSAR(NULL,0, 0.02, 0.2, 1)) ;
}

bool ruleMACD_Above() {
   return (iMACD(NULL,0, 12, 26, 9, PRICE_CLOSE, MODE_MAIN, 1) > 0) ;
}

bool ruleMACD_Below() {
   return (iMACD(NULL,0, 12, 26, 9, PRICE_CLOSE, MODE_MAIN, 1) < 0) ;
}

bool ruleLongTermRSI_Above() {
   return (iRSI(NULL,0,40,PRICE_CLOSE,1) > 50) ;
}

bool ruleLongTermRSI_Below() {
   return (iRSI(NULL,0,40,PRICE_CLOSE,1) < 50) ;
}

bool ruleShortTermRSI_Above() {
   return (iRSI(NULL,0,20,PRICE_CLOSE,1) > 50) ;
}

bool ruleShortTermRSI_Below() {
   return (iRSI(NULL,0,20,PRICE_CLOSE,1) < 50) ;
}

bool ruleLongTermStoch_Above() {
   return (iStochastic(NULL,0, 40, 1, 3, MODE_SMA, 0, 1, 1) > 50) ;
}

bool ruleLongTermStoch_Below() {
   return (iStochastic(NULL,0, 40, 1, 3, MODE_SMA, 0, 1, 1) < 50) ;
}

bool ruleShortTermStoch_Above() {
   return (iStochastic(NULL,0, 20, 1, 3, MODE_SMA, 0, 1, 1) > 50) ;
}

bool ruleShortTermStoch_Below() {
   return (iStochastic(NULL,0, 20, 1, 3, MODE_SMA, 0, 1, 1) < 50) ;
}

bool ruleLongTermCCI_Above() {
   return (iCCI(NULL,0,40,PRICE_TYPICAL,1) > 0) ;
}

bool ruleLongTermCCI_Below() {
   return (iCCI(NULL,0,40,PRICE_TYPICAL,1) < 0) ;
}

bool ruleShortTermCCI_Above() {
   return (iCCI(NULL,0,20,PRICE_TYPICAL,1) > 0) ;
}

bool ruleShortTermCCI_Below() {
   return (iCCI(NULL,0,20,PRICE_TYPICAL,1) < 0) ;
}

bool ruleVolumeAboveAvg() {
   return (Volume[1] > iCustom(NULL,0, "AvgVolume", 50, 1, 1)) ;
}

bool ruleVolumeBelowAvg() {
   return (Volume[1] < iCustom(NULL,0, "AvgVolume", 50, 1, 1)) ;
}

//+------------------------------------------------------------------+
//+ Candle Pattern functions
//+------------------------------------------------------------------+

bool candlePatternBearishEngulfing(int shift) {
   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];

   if ((C1>O1)&&(O>C)&&(O>=C1)&&(O1>=C)&&((O-C)>(C1-O1))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool candlePatternBullishEngulfing(int shift) {
   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];

   if ((O1>C1)&&(C>O)&&(C>=O1)&&(C1>=O)&&((C-O)>(O1-C1))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool candlePatternDarkCloudCover(int shift) {
   double L = Low[shift];
   double H = High[shift];

   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];
   double CL = H-L;

   double OC_HL;
   if((H - L) != 0) {
      OC_HL = (O-C)/(H-L);
   } else {
      OC_HL = 0;
   }

   double Piercing_Line_Ratio = 0.5;
   double Piercing_Candle_Length = 10;

   if ((C1>O1)&&(((C1+O1)/2)>C)&&(O>C)&&(C>O1)&&(OC_HL>Piercing_Line_Ratio)&&((CL>=Piercing_Candle_Length*gPointCoef))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool candlePatternDoji(int shift) {
   if(MathAbs(Open[shift] - Close[shift])*gPointPow < 0.6) {
      return(true);
   }
   return(false);
}

//+------------------------------------------------------------------+

bool candlePatternHammer(int shift) {
   double H = High[shift];
   double L = Low[shift];
   double L1 = Low[shift+1];
   double L2 = Low[shift+2];
   double L3 = Low[shift+3];

   double O = Open[shift];
   double C = Close[shift];
   double CL = H-L;

   double BodyLow, BodyHigh;
   double Candle_WickBody_Percent = 0.9;
   double CandleLength = 12;

   if (O > C) {
      BodyHigh = O;
      BodyLow = C;
   } else {
      BodyHigh = C;
      BodyLow = O;
   }

   double LW = BodyLow-L;
   double UW = H-BodyHigh;
   double BLa = MathAbs(O-C);
   double BL90 = BLa*Candle_WickBody_Percent;

   double pipValue = gPointCoef;

   if ((L<=L1)&&(L<L2)&&(L<L3))  {
      if (((LW/2)>UW)&&(LW>BL90)&&(CL>=(CandleLength*pipValue))&&(O!=C)&&((LW/3)<=UW)&&((LW/4)<=UW)/*&&(H<H1)&&(H<H2)*/)  {
         return(true);
      }
      if (((LW/3)>UW)&&(LW>BL90)&&(CL>=(CandleLength*pipValue))&&(O!=C)&&((LW/4)<=UW)/*&&(H<H1)&&(H<H2)*/)  {
         return(true);
      }
      if (((LW/4)>UW)&&(LW>BL90)&&(CL>=(CandleLength*pipValue))&&(O!=C)/*&&(H<H1)&&(H<H2)*/)  {
         return(true);
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool candlePatternPiercingLine(int shift) {
   double L = Low[shift];
   double H = High[shift];

   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];
   double CL = H-L;

   double CO_HL;
   if((H - L) != 0) {
      CO_HL = (C-O)/(H-L);
   } else {
      CO_HL = 0;
   }

   double Piercing_Line_Ratio = 0.5;
   double Piercing_Candle_Length = 10;

   if ((C1<O1)&&(((O1+C1)/2)<C)&&(O<C) && (CO_HL>Piercing_Line_Ratio)&&(CL>=(Piercing_Candle_Length*gPointCoef))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool candlePatternShootingStar(int shift) {
   double L = Low[shift];
   double H = High[shift];
   double H1 = High[shift+1];
   double H2 = High[shift+2];
   double H3 = High[shift+3];

   double O = Open[shift];
   double C = Close[shift];
   double CL = H-L;

   double BodyLow, BodyHigh;
   double Candle_WickBody_Percent = 0.9;
   double CandleLength = 12;

   if (O > C) {
      BodyHigh = O;
      BodyLow = C;
   } else {
      BodyHigh = C;
      BodyLow = O;
   }

   double LW = BodyLow-L;
   double UW = H-BodyHigh;
   double BLa = MathAbs(O-C);
   double BL90 = BLa*Candle_WickBody_Percent;

   double pipValue = gPointCoef;

   if ((H>=H1)&&(H>H2)&&(H>H3))  {
      if (((UW/2)>LW)&&(UW>(2*BL90))&&(CL>=(CandleLength*pipValue))&&(O!=C)&&((UW/3)<=LW)&&((UW/4)<=LW)/*&&(L>L1)&&(L>L2)*/)  {
         return(true);
      }
      if (((UW/3)>LW)&&(UW>(2*BL90))&&(CL>=(CandleLength*pipValue))&&(O!=C)&&((UW/4)<=LW)/*&&(L>L1)&&(L>L2)*/)  {
         return(true);
      }
      if (((UW/4)>LW)&&(UW>(2*BL90))&&(CL>=(CandleLength*pipValue))&&(O!=C)/*&&(L>L1)&&(L>L2)*/)  {
         return(true);
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool checkInsideTradingRange() {
   if(tradingRangeReverted == false && (TimeCurrent() < StrToTime(TimeRangeFrom) || TimeCurrent() > StrToTime(TimeRangeTo))) {
      return(false);
   } else if(tradingRangeReverted == true && (TimeCurrent() > StrToTime(TimeRangeTo) && TimeCurrent() < StrToTime(TimeRangeFrom))) {
      return(false);
   }

   return(true);
}

//+------------------------------------------------------------------+

bool isCorrectDayOfWeek(datetime time) {
   int dow = TimeDayOfWeek(time);

   if(!TradeSunday && dow == 0) { return(false); }
   if(!TradeMonday && dow == 1) { return(false); }
   if(!TradeTuesday && dow == 2) { return(false); }
   if(!TradeWednesday && dow == 3) { return(false); }
   if(!TradeThursday && dow == 4) { return(false); }
   if(!TradeFriday && dow == 5) { return(false); }
   if(!TradeSaturday && dow == 6) { return(false); }

   return(true);
}


//+------------------------------------------------------------------+

bool doublesAreEqual(double n1, double n2) {
   string s1 = DoubleToStr(n1, Digits);
   string s2 = DoubleToStr(n2, Digits);

   return (s1 == s2);
}

//+------------------------------------------------------------------+

double checkCorrectMinMaxSLPT(double slptValue) {
   double slptMin = MinimumSLPT * gPointCoef;

   if(MinimumSLPT > 0) {
      slptValue = MathMax(MinimumSLPT * gPointCoef, slptValue);
   }
   if(MaximumSLPT > 0) {
      slptValue = MathMin(MaximumSLPT * gPointCoef, slptValue);
   }

   return (slptValue);
}

//+------------------------------------------------------------------+

string getNotificationText() {
   string text = TimeToStr(TimeCurrent());
   text = StringConcatenate(text, " New Order Opened\n\n");

   text = StringConcatenate(text, " Order ticket: ", OrderTicket(),"\n");

   switch(OrderType()) {
      case OP_BUY: text = StringConcatenate(text, " Direction : Buy\n"); break;
      case OP_SELL: text = StringConcatenate(text, " Direction : Sell\n"); break;
      case OP_BUYLIMIT: text = StringConcatenate(text, " Direction : Buy Limit\n"); break;
      case OP_SELLLIMIT: text = StringConcatenate(text, " Direction : Sell Limit\n"); break;
      case OP_BUYSTOP: text = StringConcatenate(text, " Direction : Buy Stop\n"); break;
      case OP_SELLSTOP: text = StringConcatenate(text, " Direction : Sell Stop\n"); break;
   }

   text = StringConcatenate(text, " Open price: ", OrderOpenPrice(),"\n");

   text = StringConcatenate(text, " Lots: ", OrderLots(),"\n");

   return(text);
}

//+------------------------------------------------------------------+

string sqGetTimeAsStr() {
   string str = TimeToStr(Time[0], TIME_DATE);
   int period = Period();

   if(period == PERIOD_H4 || period == PERIOD_H1) {
      str = str + TimeHour(Time[0]);
   }
   if(period == PERIOD_M30 || period == PERIOD_M15 || period == PERIOD_M5 || period == PERIOD_M1) {
      str = str + " " + TimeToStr(Time[0], TIME_MINUTES);
   }

   return(str);
}

//+------------------------------------------------------------------+

int sqIsTradeAllowed(int MaxWaiting_sec = 30) {
    // check whether the trade context is free
    if(!IsTradeAllowed()) {
        int StartWaitingTime = GetTickCount();
        Print("Trade context is busy! Wait until it is free...");
        // infinite loop
        while(true) {
            // if the expert was terminated by the user, stop operation
            if(IsStopped()) {
                Print("The expert was terminated by the user!");
                return(-1);
            }
            // if the waiting time exceeds the time specified in the
            // MaxWaiting_sec variable, stop operation, as well
            if(GetTickCount() - StartWaitingTime > MaxWaiting_sec * 1000) {
                Print("The waiting limit exceeded (" + MaxWaiting_sec + " ???.)!");
                return(-2);
            }
            // if the trade context has become free,
            if(IsTradeAllowed()) {
                Print("Trade context has become free!");
                RefreshRates();
                return(1);
            }
            // if no loop breaking condition has been met, "wait" for 0.1
            // second and then restart checking
            Sleep(100);
          }
    } else {
        //Print("Trade context is free!");
        return(1);
    }
}

//+------------------------------------------------------------------+

double sqToPips(double value) {
    return(value * gPointCoef);
}/**
 * function that is called on init
 */
void customInit() {
}

/**
 * function that is called on start. If it returns false, the processing will end.
 * You can use it for your own custom checks.
 */
bool customStart() {
   return(true);
}